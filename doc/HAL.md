# HAL
The Hardware Abstraction Layer (HAL) can be understood as a layer that abstracts the hardware details from the rest of the system. In this repository, we are implementing a dummy HAL that provides car information, as if this information was coming from a sensor through a communication protocol or something like that. We also provide a way for third-party applications to access this information through the SDK-Addon, improving what is proposed in the **hello-world-service** example. So, is **highly** recommended to read the **hello-world-service** example before continuing with this one.

## Files related to the HAL

* `hardware/interfaces/dummy_car_info_hal`: This directory contains the AIDL files that define the interface of the HAL.
* `hardware/implementations/dummy_car_info_hal`: This directory contains the C++ implementation for the HAL at `DummyCarInfo.cpp`, the code that binds the HAL on the system boot at `service.cpp` and some configuration files to build the HAL.
* `package/services/profusion/dummy-car-info-service`: Contains the service that communicates with the `dummy_car_info_hal` and a Manager that binds this service and is exposed to 3rd party applications through the SDK-Addon.

## Understading the key files

Lets take a look at the key files in the HAL implementation:

### The HAL service itself

#### `IDummyCarInfoHAL.aidl`
``` java
package profusion.hardware.dummy_car_info_hal;

@VintfStability
interface IDummyCarInfoHAL{
    void getCarInfo(out profusion.hardware.dummy_car_info_hal.CarInfo carInfo);
}
```

#### `CarInfo.aidl`
``` java
package profusion.hardware.dummy_car_info_hal;

@VintfStability
parcelable CarInfo{
    int velocity;
    int gear;
    int fuel;
}
```

The first .aidl file defines the interface that the HAL service should implement, signalizing that the method `getCarInfo` will output a `CarInfo` object (note that **this isn't a return**, the method actually receives an object and fills it with the information using reference). The second .aidl file defines the `CarInfo` itself.

Before any full compilation, it is necessary to run the `m profusion.hardware.dummy_car_info_hal-update-api` command to freeze and version the AIDL interfaces, which will generate the `hardware/interfaces/dummy_car_info_hal/aidl/aidl_api` directory at the AOSP source tree.

#### `hardware/intefaces/dummy_car_info_hal/aidl/Android.bp`
```
package {
    default_applicable_licenses: ["hardware_interfaces_license"],
}

aidl_interface {
    name: "profusion.hardware.dummy_car_info_hal",
    srcs: ["profusion/hardware/dummy_car_info_hal/*.aidl"],
    stability: "vintf",
    vendor_available: true,
    backend: {
        cpp: {
            enabled: false,
        },
        java: {
            sdk_version: "module_current",
        },
    },
    owner: "Profusion",
}

```

Defines the AIDL interfaces to the build system. The 'stability: "vintf"' indicates that these are [Stable AIDLs](https://source.android.com/docs/core/architecture/aidl/stable-aidl). 

#### `DummyCarInfoHAL.h`
```cpp
#pragma once

#include <aidl/profusion/hardware/dummy_car_info_hal/BnDummyCarInfoHAL.h>
#include <mutex>

namespace aidl {
namespace profusion {
namespace hardware {
namespace dummy_car_info_hal {

class DummyCarInfoHAL : public BnDummyCarInfoHAL {
    virtual ndk::ScopedAStatus getCarInfo(CarInfo* carInfo) override;

protected:
    std::mutex dummyCarInfoMutex;
};

}
}
}
}
```

`DummyCarInfoHAL.h` defines the class that implements the definitions of `IDummyCarInfoHAL` AIDL interface, once it inherits from the  `Bn` class, which is auto-generated by the build system. It also defines a mutex to prevent simultaneous access to the car information.

#### `DummyCarInfoHAL.cpp`
```cpp
#include "DummyCarInfoHAL.h"

#include <android-base/logging.h>

namespace aidl {
namespace profusion {
namespace hardware {
namespace dummy_car_info_hal {

ndk::ScopedAStatus DummyCarInfoHAL::getCarInfo(CarInfo* carInfo) {
    std::unique_lock<std::mutex> lock(dummyCarInfoMutex);
    LOG(INFO) << "DummyHAL: getCarInfo called!";
    carInfo->velocity = 100;
    carInfo->fuel = 50;
    carInfo->gear = 4; 
    return ndk::ScopedAStatus::ok();
}

}
}
}
}
```

The `DummyCarInfoHAL.cpp` implements the `getCarInfo` method. This method is responsible for filling the `CarInfo` object with the dummy car information. Note that here we are not instantiating the `CarInfo` object, instead, we are filling the object that was passed as a parameter to the method. We use `ndk::ScopedAStatus` to handle the completion of the method. Here we have a simple implementation that always returns `ok`, but is possible to handle errors as well.

#### `service.cpp`
```cpp
#include "DummyCarInfoHAL.h"

#include <android/binder_manager.h>
#include <android/binder_process.h>
#include <android-base/logging.h>

using aidl::profusion::hardware::dummy_car_info_hal::DummyCarInfoHAL;

int main() {
    LOG(INFO) << "DummyHAL: Main HAL being called";

    ABinderProcess_setThreadPoolMaxThreadCount(0);

    std::shared_ptr<DummyCarInfoHAL> dummyCarInfoHAL = ndk::SharedRefBase::make<DummyCarInfoHAL>();

    const std::string instance = std::string() + DummyCarInfoHAL::descriptor + "/default";
    binder_status_t status = AServiceManager_addService(dummyCarInfoHAL->asBinder().get(), instance.c_str());
    CHECK_EQ(status, STATUS_OK);

    ABinderProcess_joinThreadPool();
    LOG(INFO) << "DummyHAL: Main HAL exiting main";
    return EXIT_FAILURE;
}
```

The `service.cpp` is responsible for binding the HAL service at the ServiceManager, allowing other processes and services to communicate with it. It also starts the thread pool to handle the incoming requests. It's important to note that is expected that `ABinderProcess_joinThreadPool();` never returns, so the `return EXIT_FAILURE;` acts more like a placeholder.

#### `hardware/implementations/dummy_car_info_hal/default/Android.bp`
```
cc_library_static {
    name: "profusion.hardware.dummy_car_info_hal-lib",
    srcs: [
        "DummyCarInfoHAL.cpp",
        "service.cpp",
    ],
    export_include_dirs: [
        "include",
    ],
    shared_libs: [
        "profusion.hardware.dummy_car_info_hal-V1-ndk",
        "libbase",
        "liblog",
        "libbinder_ndk",
    ],
    vendor: true,
}

cc_binary {
    name: "profusion.hardware.dummy_car_info_hal-service",
    relative_install_path: "hw",
    init_rc: ["dummy_car_info-default.rc"],
    vintf_fragments: ["dummy_car_info-default.xml"],
    srcs: [
        "DummyCarInfoHAL.cpp",
        "service.cpp",
    ],
    static_libs: [
        "profusion.hardware.dummy_car_info_hal-lib",
    ],
    shared_libs: [
        "profusion.hardware.dummy_car_info_hal-V1-ndk",
        "libbase",
        "liblog",
        "libbinder_ndk",
    ],
    vendor: true,
}
```

This `Android.bp` defines the build rules for the HAL service. `profusion.hardware.dummy_car_info_hal-V1-ndk` is the library that contains the generated code from AIDL interfaces. Lastly, the binary `profusion.hardware.dummy_car_info_hal-service` is installed at the `vendor/hw` directory and is referenced at the init_rc as shown below to bind the service at the system boot.

#### `dummy_car_info-default.rc`
```
service profusion.hardware.dummy_car_info_hal-service /vendor/bin/hw/profusion.hardware.dummy_car_info_hal-service
    interface aidl profusion.hardware.dummy_car_info_hal.IDummyCarInfoHAL/default
    class hal
    user nobody
    group nobody
```

The `dummy_car_info-default.rc` file defines the rules to start the HAL service, creating a link between the interface and the binary previously defined. In this case, it will be started at system boot, as the property `disabled` was omitted (for more informations, see [Dynamically available HAL](https://source.android.com/docs/core/architecture/hal/dynamic-lifecycle)).

### SELinux policies for the services

Android uses SELinux to enforce access control to resources like files, services, and so on. By default, everything is denied, so we need to explicitly indicate what our HAL Service is allowed to do and what processes are allowed to communicate with it. The policies need to be attached to a `TARGET_PRODUCT`, so we define them at the `device/profusion/sepolicy` directory. Also, the policies need to be included in the `<TARGET_PRODUCT>.mk` file. In our case, we can achieve this by adding the following lines to the `device/profusion/profusion_sdk_addon.mk`:

```
BOARD_SEPOLICY_DIRS += \
    device/profusion/sepolicy/daemon \
    device/profusion/sepolicy/interface
```

And of course, the policies files:

#### `file_contexts`
```
/vendor/bin/hw/profusion.hardware.dummy_car_info_hal-service    u:object_r:dummy_car_info_hal_exec:s0
```

#### `dummy.te`
```
type dummy_car_info_hal, domain;
type dummy_car_info_hal_exec, exec_type, file_type, vendor_file_type;

init_daemon_domain(dummy_car_info_hal)

binder_call(dummy_car_info_hal, hwservicemanager)

allow dummy_car_info_hal servicemanager:binder { call transfer };

allow system_app dummy_car_info_hal:binder { call };
allow platform_app dummy_car_info_hal:binder { call };

domain_auto_trans(init, dummy_car_info_hal_exec, dummy_car_info_hal)
```

In this files, we define and associate the context and the domain to our policies. Allowing the domain of `dummy_car_info_hal` to communicate with the `ServiceManager`, and allowing the `system_app` (service from packages) and `platform_app` (application) to communicate with the `dummy_car_info_hal`.

#### `service_contexts`
```
profusion.hardware.dummy_car_info_hal.IDummyCarInfoHAL/default u:object_r:dummy_server_service:s0
```

#### `service.te`
```
type dummy_server_service, hal_service_type, protected_service, service_manager_type;

allow dummy_car_info_hal dummy_server_service:service_manager add;
allow platform_app dummy_server_service:service_manager find;

```

In this files we define the policies for the service that is bounded at system boot. We allow that the `dummy_car_info_hal` context can add the `dummy_server_service` to the `ServiceManager` and that the `platform_app` can find this service.

PS: More information about SELinux policies can be found at the [Android Developer Documentation](https://source.android.com/docs/security/features/selinux/implement).

### Files related to the SDK

#### `DummyCarInfoService.java`
```java
...
    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate");
        try {
            IBinder binder = ServiceManager.getService("profusion.hardware.dummy_car_info_hal.IDummyCarInfoHAL/default");
            if (binder == null) {
                Log.e(TAG, "Failed to get DummyCarInfoHAL from ServiceManager");
                return;
            }
            halService = IDummyCarInfoHAL.Stub.asInterface(binder);
            if (halService == null) {
                Log.e(TAG, "Failed to get DummyCarInfoHAL service");
                return;
            }
            Log.d(TAG, "HAL binded");
        } catch (Exception e) {
            Log.e(TAG, "Exception on HAL bind", e);
        }
    }
...
    private String getCarInfoFromHAL() throws Exception {
        Log.d(TAG, "Getting car info from HAL");
        if (halService != null) {
            try {
                CarInfo carInfo = new CarInfo();
                halService.getCarInfo(carInfo);
                Log.d(TAG, "Car info received from HAL");
                return "Velocity: " + carInfo.velocity + ", Fuel: " + carInfo.fuel + ", Gear: " + carInfo.gear;
            } catch (Exception e) {
                Log.e(TAG, "Exception on getCarInfo", e);
                throw new Exception("Failed to get car info from HAL", e);
            }
        } else {
            Log.e(TAG, "HAL service is not initialized");
            throw new Exception("HAL service is not initialized");
        }
    }
```

Beyond what we already know of the `hello-world-service`, this one uses the ServiceManager to retrieve an instance of the HAL Service that was bonded at the system boot. In this way, we can establish communication between the two different layers without concerns about languages and implementations. To retrieve the car information, we simply need to call the `getCarInfo` method passing an instance of the CarInfo object.

#### `DummyCarInfoManager.java`
```java
public class DummyCarInfoManager {
    private static final String TAG = "DummyCarInfoManager";
    private IDummyCarInfoService dummyCarInfoService;
    private Context context;
    private boolean isBound = false;
    private static final String DUMMY_CAR_SERVICE_PACKAGE = "com.profusion.dummyCarInfo";
    private static final String DUMMY_CAR_SERVICE = "com.profusion.dummyCarInfo.DummyCarInfoService";

    public DummyCarInfoManager(Context context) {
        this.context = context;
        bindService();
    }

    private void bindService() {
        try {
            Intent intent = new Intent();
            intent.setComponent(new ComponentName(DUMMY_CAR_SERVICE_PACKAGE, DUMMY_CAR_SERVICE));
            context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
        } catch (Exception e) {
            Log.e(TAG, "Exception while binding to DummyCarInfoService", e);
        }
    }

    public void unbindService() {
        if (isBound) {
            context.unbindService(serviceConnection);
            isBound = false;
        }
    }

    private ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            dummyCarInfoService = IDummyCarInfoService.Stub.asInterface(service);
            isBound = true;
            Log.d(TAG, "DummyCarInfoService connected");
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            dummyCarInfoService = null;
            isBound = false;
            Log.d(TAG, "DummyCarInfoService disconnected");
        }
    };

    public String getCarInfo() throws Exception {
        if (dummyCarInfoService != null) {
            String carInfo = dummyCarInfoService.getCarInfo();
            if (carInfo != null) {
                return carInfo;
            } else {
                Log.e(TAG, "Failed to get car info from DummyCarInfoService");
                throw new Exception("Failed to get car info from DummyCarInfoService");
            }
        } else {
            Log.e(TAG, "DummyCarInfoService is not bound");
            throw new Exception("DummyCarInfoService is not bound");
        }
    }
}
```

Instead of exposing the `DummyCarInfoService` (as we did in the `hello-world-service`), here we define a `DummyCarInfoManager` that is responsible for binding the service and retrieving the car information. This way, we can abstract the service from the application, making it easier to 3rd party applications to use it.

The remaining build files are very similar to the `hello-world-service` example, so we are not going to detail them here. The main difference is that we need to include the `profusion.hardware.dummy_car_info_hal-service` module in the `PRODUCT_PACKAGES` variable at `device/profusion/profusion_sdk_addon.mk` file.

## Using the Manager in a application

The add-on that was added to Android Studio following [Adding the SDK Add-on to Android Studio](../README.md#adding-the-sdk-add-on-to-android-studio) already contains the `.jar` for the `DummyCarInfoManager`, then to use it in an application (after adding the SDK Add-on as a dependency on `build.gradle`) you just need to import the class, create an instance of it and call the `getCarInfo` method.

```kotlin
import com.profusion.dummyCarInfo.DummyCarInfoManager
...
override fun onStart() {
    super.onStart()
    dummyCarInfoManager = DummyCarInfoManager(this)
}
...
fun getCarInfo() : String {
    return dummyCarInfoManager.getCarInfo()
}
```

## Building and running

If you followed the instructions of the [Building the SDK Addon](../README.md#building-the-sdk-addon) section in README, you already have an emulator with the system image containing the HAL and the SDK. All you need to do is run the emulator and install the sample app!

![App with button to call DummyCarInfoManager](../assets/running_app_hal.gif)
